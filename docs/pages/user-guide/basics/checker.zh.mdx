import { Callout, FileTree, Tab, Tabs } from "nextra-theme-docs";

# Checker

Checkerï¼Œå³ã€Œæ£€æŸ¥å™¨ã€ï¼Œé€šå¸¸ç”¨äºåœ¨æ­£ç¡®ç­”æ¡ˆä¸å”¯ä¸€çš„é¢˜ç›®å¯¹é€‰æ‰‹ç­”æ¡ˆè¿›è¡Œæ£€éªŒï¼Œæˆ–è€…ç»†åŒ–å¾—åˆ†éœ€æ±‚ï¼

Checker é€šå¸¸éœ€è¦å¤„ç†ä¸‰ä¸ªæ–‡ä»¶ï¼š

- æµ‹è¯•ç‚¹è¾“å…¥æ–‡ä»¶ï¼ˆ`inf`ï¼‰ï¼šå³é€‰æ‰‹ç¨‹åºè¿è¡Œæ—¶çš„è¾“å…¥æ–‡ä»¶ï¼
- é€‰æ‰‹è¾“å‡ºæ–‡ä»¶ï¼ˆ`ouf`ï¼‰ï¼šå³é€‰æ‰‹ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„è¾“å‡ºæ–‡ä»¶ï¼
- æ ‡å‡†ç­”æ¡ˆæ–‡ä»¶ï¼ˆ`ans`ï¼‰ï¼šå‚¨å­˜æ­£ç¡®ç­”æ¡ˆçš„æ–‡ä»¶ï¼å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œç­‰ä»·äºæ ‡å‡†ç¨‹åºï¼ˆstdï¼‰è¿è¡Œæ—¶äº§ç”Ÿçš„è¾“å‡ºæ–‡ä»¶ï¼

Checker é€šå¸¸éœ€è¦æ£€æµ‹ä¸¤ä¸ªæ¡ä»¶ï¼š

- æ ¹æ®æµ‹è¯•ç‚¹çš„è¾“å…¥æ–‡ä»¶ï¼Œåˆ¤æ–­é€‰æ‰‹çš„è¾“å‡ºæ˜¯å¦ã€Œæœ‰æ•ˆã€ï¼ˆå³ç¬¦åˆè¾“å‡ºæ ¼å¼å’Œçº¦æŸï¼‰ï¼
- å°†é€‰æ‰‹çš„è¾“å‡ºä¸æ ‡å‡†ç­”æ¡ˆè¿›è¡Œæ¯”è¾ƒï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦ã€Œç­‰ä»·ã€ï¼ˆå³æ ¹æ®é—®é¢˜è§„åˆ™åœ¨é€»è¾‘ä¸Šæ­£ç¡®ï¼‰ï¼

## åŸºç¡€

<Callout type="info">
æœ¬èŠ‚çš„ç›¸å…³ä»£ç è§ [GitHub ä»“åº“](https://github.com/rindag-devs/cplib/tree/main/tests/checker/0-i32-a-plus-b)ï¼
</Callout>

æˆ‘ä»¬å…ˆä»ä¸€é“ç®€å•çš„é¢˜ç›®å¼€å§‹è®²è§£ checker çš„ç¼–å†™å’Œä½¿ç”¨ï¼

> **é¢˜ç›®æè¿°**ï¼šç»™å®šä¸¤ä¸ªæ•´æ•° $a$ å’Œ $b$ï¼ˆ$-1000 \le a,b \le 1000$ï¼‰ï¼ä½ éœ€è¦è¾“å‡º $a$ ä¸ $b$ çš„å’Œï¼

### ç¼–å†™

é¦–å…ˆæˆ‘ä»¬ä»ä¸€ä¸ªç©ºå·¥ä½œç›®å½•å¼€å§‹ï¼Œå°† `cplib.hpp` å¤åˆ¶åˆ°å·¥ä½œç›®å½•ä¸‹ï¼ç„¶åæ–°å»ºæ–‡ä»¶ `chk.cpp`ï¼Œå¹¶è¾“å…¥ä»¥ä¸‹ä»£ç ï¼š

```cpp filename="chk.cpp" copy showLineNumbers
#include "cplib.hpp"

using namespace cplib;

// Define the Input struct to read problem-specific inputs (A and B for A+B problem)
struct Input {
  int a, b;

  static Input read(var::Reader& in) {
    // Read integer 'a' within range [-1000, 1000]
    auto a = in.read(var::i32("a", -1000, 1000));
    // Read integer 'b' within range [-1000, 1000]
    auto b = in.read(var::i32("b", -1000, 1000));
    return {a, b};
  }
};

// Define the Output struct to read the answer and evaluate it
struct Output {
  int ans;

  // Static read method to parse participant/jury output
  // It receives a var::Reader and the Input struct for context if needed.
  static Output read(var::Reader& in, const Input&) {
    // Read integer 'ans' within range [-2000, 2000]
    auto ans = in.read(var::i32("ans", -2000, 2000));
    return {ans};
  }

  // Static evaluate method to compare participant's output with jury's output
  // It receives an evaluate::Evaluator, participant's output (pans),
  // jury's output (jans), and the original Input.
  static evaluate::Result evaluate(evaluate::Evaluator& ev, const Output& pans, const Output& jans,
                                   const Input&) {
    // Use ev.eq to compare the 'ans' field.
    // If pans.ans == jans.ans, it contributes to AC. Otherwise, it marks WA.
    auto res = evaluate::Result::ac();
    res &= ev.eq("ans", pans.ans, jans.ans);
    return res;
  }
};

// Register the checker with CPLib, specifying the Input and Output structs.
// This macro sets up the main checker logic behind the scenes.
CPLIB_REGISTER_CHECKER(Input, Output);
```

æˆ‘ä»¬å°†é€è¡Œè®²è§£è¿™æ®µä»£ç ï¼

```cpp
using namespace cplib;
```

CPLib çš„ä¸»è¦åŠŸèƒ½éƒ½å­˜æ”¾åœ¨å‘½åç©ºé—´ `cplib` ä¸­ï¼ç”±äºç®—æ³•ç«èµ›ä½¿ç”¨çš„ç¨‹åºä¸€èˆ¬å¾ˆçŸ­ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šè®²ï¼Œ`using namespace cplib;` å¯æå¤§ä¼˜åŒ–å¼€å‘æ•ˆç‡ï¼

```cpp
struct Input { /* ... */ };
```

`Input` ç»“æ„ä½“å°è£…äº†ä»é—®é¢˜è¾“å…¥æ–‡ä»¶è¯»å–çš„æ‰€æœ‰æ•°æ®ï¼å®ƒå¿…é¡»åŒ…å«ä¸€ä¸ªé™æ€æ–¹æ³• `read`ï¼Œè¯¥æ–¹æ³•ä»¥ `cplib::var::Reader&` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°å¹¶è¿”å›ä¸€ä¸ª `Input` å®ä¾‹ï¼æ­¤æ–¹æ³•è´Ÿè´£è§£æè¾“å…¥æ–‡ä»¶å¹¶å¯¹è¾“å…¥æ•°æ®æœ¬èº«æ‰§è¡Œä»»ä½•å¿…è¦çš„åˆå§‹éªŒè¯ï¼

```cpp
struct Output { /* ... */ };
```

`Output` ç»“æ„ä½“å°è£…äº†ä»ç¨‹åºè¾“å‡ºæ–‡ä»¶ï¼ˆåŒ…æ‹¬é€‰æ‰‹å’Œè¯„æµ‹æ–¹ï¼‰è¯»å–çš„æ‰€æœ‰æ•°æ®ï¼å®ƒå¿…é¡»åŒ…å«ï¼š

- ä¸€ä¸ªé™æ€æ–¹æ³• `read`ï¼Œå®ƒä»¥ `cplib::var::Reader&` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¹¶å¯é€‰åœ°ä»¥ `const Input&` ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼ˆå¦‚æœè¾“å‡ºè§£æä¾èµ–äºè¾“å…¥æ•°æ®ï¼‰ï¼å®ƒè¿”å›ä¸€ä¸ª `Output` å®ä¾‹ï¼æ­¤æ–¹æ³•è´Ÿè´£è§£æè¾“å‡ºæ–‡ä»¶å¹¶å¯¹è¾“å‡ºæ ¼å¼å’Œçº¦æŸæ‰§è¡Œã€Œæœ‰æ•ˆæ€§ã€æ£€æŸ¥ï¼å¦‚æœè¾“å‡ºæ— æ•ˆï¼ˆä¾‹å¦‚ï¼Œè¶…å‡ºèŒƒå›´ï¼Œæ ¼å¼é”™è¯¯ï¼‰ï¼Œå®ƒåº”è¯¥è°ƒç”¨ `in.fail("message")`ï¼
- ä¸€ä¸ªé™æ€æ–¹æ³• `evaluate`ï¼Œå®ƒä»¥ `evaluate::Evaluator&`ã€`const Output& pans`ï¼ˆé€‰æ‰‹è¾“å‡ºï¼‰ã€`const Output& jans`ï¼ˆè¯„æµ‹æ–¹è¾“å‡ºï¼‰å’Œ `const Input& input` ä½œä¸ºå‚æ•°ï¼å®ƒè¿”å›ä¸€ä¸ª `evaluate::Result`ï¼æ­¤æ–¹æ³•è´Ÿè´£æ ¹æ®é—®é¢˜çš„é€»è¾‘æ­£ç¡®æ€§è§„åˆ™æ¯”è¾ƒ `pans` å’Œ `jans`ï¼

```cpp
  auto a = in.read(var::i32("a", -1000, 1000));
```

è¿™è¡Œä»£ç æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ **å˜é‡è¯»å–æ¨¡æ¿** æ¥è¯»å–å˜é‡ï¼`cplib::var::i32` æ˜¯ `cplib::var::Int<int32_t>` çš„åˆ«åï¼å®ƒæ˜¯ä¸€ä¸ªæ¨¡æ¿ï¼Œç”¨äºæŒ‡å®šå¦‚ä½•è¯»å–ä¸€ä¸ª 32 ä½æœ‰ç¬¦å·æ•´æ•°ï¼æ„é€ å‡½æ•°å‚æ•° `("a", -1000, 1000)` å®šä¹‰äº†ï¼š

- `"a"`ï¼šå˜é‡çš„åç§°ï¼å½“è¯»å–è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæ­¤åç§°å°†ä¸è¯»å–å †æ ˆè·Ÿè¸ªä¸€èµ·æ˜¾ç¤ºåœ¨é”™è¯¯æ¶ˆæ¯ä¸­ï¼Œä½¿é”™è¯¯æŠ¥å‘Šæ›´å…·å¯è¯»æ€§ï¼
- `-1000, 1000`ï¼šæ•´æ•°å…è®¸çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼CPLib ä¼šè‡ªåŠ¨æ£€æŸ¥è¯»å–çš„å€¼æ˜¯å¦åœ¨æ­¤èŒƒå›´å†…ï¼

<Callout type="info">
`cplib::var::Int<T>` çš„æ„é€ å‡½æ•°å£°æ˜ä¸ºï¼š

- `explicit Int();`
- `explicit Int(std::string name);`
- `explicit Int(std::optional<T> min, std::optional<T> max);`
- `explicit Int(std::string name, std::optional<T> min, std::optional<T> max);`

å°½ç®¡ `name` å‚æ•°å¯ä»¥è¢«çœç•¥ï¼Œä½† **å¼ºçƒˆä¸å»ºè®®** è¿™æ ·åšï¼Œå› ä¸ºå®ƒä¼šé™ä½é”™è¯¯æŠ¥å‘Šçš„å¯è¯»æ€§ï¼
</Callout>

```cpp
    auto res = evaluate::Result::ac();
    res &= ev.eq("ans", pans.ans, jans.ans);
    return res;
```

åœ¨ `Output::evaluate` æ–¹æ³•å†…éƒ¨ï¼Œ`evaluate::Evaluator& ev` ç”¨äºæ¯”è¾ƒç»“æœï¼`ev.eq("ans", pans.ans, jans.ans)` æ¯”è¾ƒé€‰æ‰‹è¾“å‡ºï¼ˆ`pans`ï¼‰çš„ `ans` å­—æ®µä¸è¯„æµ‹æ–¹è¾“å‡ºï¼ˆ`jans`ï¼‰ï¼å¦‚æœå®ƒä»¬ç›¸ç­‰ï¼Œåˆ™å¾—åˆ°ã€ŒAcceptedã€ç»“æœï¼å¦‚æœå®ƒä»¬ä¸ç›¸ç­‰ï¼Œåˆ™å°†ç»“æœæ ‡è®°ä¸ºã€ŒWrong Answerã€ï¼Œå¹¶æä¾›åŒ…å«å˜é‡åã€Œansã€å’Œå€¼çš„è¯¦ç»†æ¶ˆæ¯ï¼

å½“è¾“å‡ºæ–‡ä»¶ï¼ˆé€‰æ‰‹æˆ–ç­”æ¡ˆï¼‰ä¸ç¬¦åˆå…¶ `read` æ–¹æ³•ä¸­æŒ‡å®šçš„æ ¼å¼æˆ–èŒƒå›´çº¦æŸæ—¶ï¼ŒCPLib å°†è‡ªåŠ¨é€€å‡ºç¨‹åºå¹¶æŠ¥å‘Šé”™è¯¯ï¼å¯¹äºé€‰æ‰‹çš„è¾“å‡ºï¼Œè¿™å°†å¯¼è‡´ã€ŒWrong Answerã€ï¼å¯¹äºç­”æ¡ˆæ–¹çš„è¾“å‡ºï¼Œè¿™å°†å¯¼è‡´ã€ŒInternal Errorã€ï¼ˆå†…éƒ¨é”™è¯¯ï¼‰ï¼Œè¡¨æ˜æµ‹è¯•æ•°æ®æœ¬èº«å­˜åœ¨é—®é¢˜ï¼

```cpp
CPLIB_REGISTER_CHECKER(Input, Output);
```

`CPLIB_REGISTER_CHECKER(InputStruct, OutputStruct)` å®å°†ç¨‹åºæ³¨å†Œä¸º CPLib checkerï¼`InputStruct` å’Œ `OutputStruct` æ˜¯å®šä¹‰å¦‚ä½•è¯»å–é—®é¢˜è¾“å…¥ä»¥åŠå¦‚ä½•è¯»å–å’Œè¯„ä¼°ç¨‹åºè¾“å‡ºçš„ç»“æ„ä½“åç§°ï¼CPLib å°†åœ¨å†…éƒ¨ç®¡ç† `main` å‡½æ•°å¹¶è°ƒç”¨è¿™äº›ç»“æ„ä½“çš„ `read` å’Œ `evaluate` æ–¹æ³•ï¼

<Callout type="warning">
æ³¨å†Œä¸º CPLib ç¨‹åºçš„ checker å¿…é¡»åœ¨ `evaluate` æ–¹æ³•ä¸­ä½¿ç”¨ `evaluate::Evaluator` æ–¹æ³•ï¼ˆå¦‚ `ev.eq`ã€`ev.fail`ï¼‰ï¼Œæˆ–åœ¨ `read` æ–¹æ³•ä¸­ä½¿ç”¨ `in.fail()` æ¥æŠ¥å‘Šé”™è¯¯å¹¶é€€å‡ºï¼**ä¸å…è®¸** ç›´æ¥ä½¿ç”¨ `std::exit` ç­‰å‡½æ•°è¿›è¡Œå¸¸è§„é”™è¯¯æŠ¥å‘Šï¼`panic` ä»…åº”ç”¨äºä¸å¯æ¢å¤çš„å†…éƒ¨é”™è¯¯ï¼Œä¾‹å¦‚ checker é€»è¾‘æœ¬èº«çš„ä¸¥é‡é”™è¯¯ï¼Œæˆ– `ev.fail()` æ— æ³•ä¼˜é›…å¤„ç†çš„æ— æ•ˆè¯„æµ‹æ–¹ç­”æ¡ˆï¼
</Callout>

### ä½¿ç”¨

<Tabs items={['UNIX-like', 'Windows']} storageKey="selected-os">
<Tab>
æ‰“å¼€ç»ˆç«¯ï¼Œå¯¼èˆªåˆ°ä½ åˆšåˆšåˆ›å»ºçš„å·¥ä½œç›®å½•ï¼Œç„¶åæ‰§è¡Œç¼–è¯‘å‘½ä»¤ä»¥ç¼–è¯‘ checkerï¼Œé€šå¸¸ç±»ä¼¼äºï¼š

```bash
g++ chk.cpp -o chk -std=c++20
```

<Callout type="warning">CPLib æ‰€éœ€çš„æœ€ä½ C++ æ ‡å‡†æ˜¯ C++ 20ï¼</Callout>

æ¥ä¸‹æ¥ï¼Œåœ¨å·¥ä½œç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªåä¸º `data/` çš„æ–‡ä»¶å¤¹ï¼Œç”¨äºå­˜å‚¨ checker ä½¿ç”¨çš„æµ‹è¯•ç‚¹ï¼Œå¹¶å°†æµ‹è¯•æ•°æ®æ”¾å…¥å…¶ä¸­ï¼åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `data/0.in`ã€`data/0.out` å’Œ `data/0.ans` ä½œä¸ºæµ‹è¯•æ•°æ®çš„åç§°ï¼

æ­¤æ—¶ï¼Œä½ çš„å·¥ä½œç›®å½•ç»“æ„åº”å¦‚ä¸‹æ‰€ç¤ºï¼š

<FileTree>
  <FileTree.Folder name="data" defaultOpen>
    <FileTree.File name="0.ans" />
    <FileTree.File name="0.in" />
    <FileTree.File name="0.out" />
  </FileTree.Folder>
  <FileTree.File name="chk.cpp" />
  <FileTree.File name="cplib.hpp" />
</FileTree>

åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æ¥æµ‹è¯•ä½ çš„ checkerï¼š

```bash
./chk data/0.in data/0.out data/0.ans
```

å¦‚æœåˆ°æ­¤ä¸ºæ­¢ä¸€åˆ‡æ­£å¸¸ï¼Œä½ ä¼šçœ‹åˆ° checker è¾“å‡ºä»¥ä¸‹ç»“æœï¼š

```ansi
[0;32mAccepted[0m, scores [0;33m100.0[0m of 100.
```

</Tab>
<Tab>
å¯åŠ¨ `cmd.exe` æˆ– Windows ç»ˆç«¯åº”ç”¨ç¨‹åºï¼Œå¯¼èˆªåˆ°ä½ åˆšåˆšåˆ›å»ºçš„å·¥ä½œç›®å½•ï¼Œç„¶åæ‰§è¡Œç¼–è¯‘å‘½ä»¤ä»¥ç¼–è¯‘ checkerï¼Œé€šå¸¸ç±»ä¼¼äºï¼š

```cmd
g++ chk.cpp -o chk.exe -std=c++20
```

<Callout type="warning">CPLib æ‰€éœ€çš„æœ€ä½ C++ æ ‡å‡†æ˜¯ C++ 20ï¼</Callout>

æ¥ä¸‹æ¥ï¼Œåœ¨å·¥ä½œç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªåä¸º `data/` çš„æ–‡ä»¶å¤¹ï¼Œç”¨äºå­˜å‚¨ checker ä½¿ç”¨çš„æµ‹è¯•ç‚¹ï¼Œå¹¶å°†æµ‹è¯•æ•°æ®æ”¾å…¥å…¶ä¸­ï¼åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `data/0.in`ã€`data/0.out` å’Œ `data/0.ans` ä½œä¸ºæµ‹è¯•æ•°æ®çš„åç§°ï¼

æ­¤æ—¶ï¼Œä½ çš„å·¥ä½œç›®å½•ç»“æ„åº”å¦‚ä¸‹æ‰€ç¤ºï¼š

<FileTree>
  <FileTree.Folder name="data" defaultOpen>
    <FileTree.File name="0.ans" />
    <FileTree.File name="0.in" />
    <FileTree.File name="0.out" />
  </FileTree.Folder>
  <FileTree.File name="chk.cpp" />
  <FileTree.File name="cplib.hpp" />
</FileTree>

åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œä»¥ä¸‹å‘½ä»¤æ¥æµ‹è¯•ä½ çš„ checkerï¼š

```cmd
.\chk data\0.in data\0.out data\0.ans
```

å¦‚æœåˆ°æ­¤ä¸ºæ­¢ä¸€åˆ‡æ­£å¸¸ï¼Œä½ ä¼šçœ‹åˆ° checker è¾“å‡ºä»¥ä¸‹ç»“æœï¼š

```ansi
[0;32mAccepted[0m, scores [0;33m100.0[0m of 100.
```

<Callout type="warning">
Windows 10 [è‡ª v1511 èµ·](https://www.reddit.com/r/Windows10/comments/44czox/windows_10_v1511_adds_support_for_ansi_escape/) æ”¯æŒ ANSI é¢œè‰²ï¼å¦‚æœä½ åœ¨ä½¿ç”¨æ—©æœŸç‰ˆæœ¬çš„ Windowsï¼Œä¸” checker çš„è¾“å‡ºåŒ…å«æ— æ³•è¯†åˆ«çš„ä¹±ç ï¼Œå¯ä»¥å°è¯•ä»¥ä¸‹å‡ ç§è§£å†³æ–¹æ¡ˆï¼š

- å®‰è£… [ANSICON](https://github.com/adoxa/ansicon)ï¼Œå®ƒå¯ä»¥åœ¨ cmd.exe ä¸­å¯ç”¨ ANSI é¢œè‰²ï¼
- ä½¿ç”¨å…¶ä»–æ”¯æŒ ANSI é¢œè‰²çš„ç»ˆç«¯æ¨¡æ‹Ÿå™¨ï¼
- è®¾ç½®ç¯å¢ƒå˜é‡ `NO_COLOR=1` ä»¥ç›´æ¥ç¦ç”¨ checker çš„å½©è‰²è¾“å‡ºï¼
</Callout>
</Tab>
</Tabs>

<Callout>
å¦‚æœä½ æƒ³è‡ªè¡Œå°è¯•ï¼Œå¯ä»¥ï¼š

- å°è¯•æ›´æ”¹æµ‹è¯•ç‚¹è¾“å…¥æ–‡ä»¶ã€é€‰æ‰‹è¾“å‡ºæ–‡ä»¶å’Œæ ‡å‡†ç­”æ¡ˆæ–‡ä»¶çš„å†…å®¹ï¼Œå¹¶è§‚å¯Ÿ checker è¾“å‡ºçš„å˜åŒ–ï¼
- è¿è¡Œ `./chk --help`ï¼Œè§‚å¯Ÿæ›´æ”¹ `--report-format` å‘½ä»¤è¡Œå‚æ•°ä»¥åŠè®¾ç½® `NO_COLOR=1` æˆ– `CLICOLOR_FORCE=1` ç¯å¢ƒå˜é‡å¯¹ checker è¾“å‡ºçš„å½±å“ï¼
</Callout>

## è¿›é˜¶

<Callout type="info">
æœ¬èŠ‚çš„ç›¸å…³ä»£ç è§ [GitHub ä»“åº“](https://github.com/rindag-devs/cplib/tree/main/tests/checker/2-shortest-path)ï¼
</Callout>

ç®—æ³•ç«èµ›ä¸­å®é™…çš„é¢˜ç›®ä¸ä¼šåƒ A+B è¿™ä¹ˆç®€å•ï¼è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªç¨å¾®å¤æ‚çš„ä¾‹å­ï¼

> **é¢˜ç›®æè¿°**ï¼šç»™å®šä¸€å¼ ç‚¹æ•°ä¸º $n$ï¼ˆ$1 \le n \le 100$ï¼‰ï¼Œè¾¹æ•°ä¸º $m$ï¼ˆ$1 \le n \le 100$ï¼‰çš„æ— å‘è¿é€šç®€å•å›¾ï¼Œç¬¬ $i$ æ¡è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹åˆ†åˆ«ä¸º $u_i$ å’Œ $v_i$ï¼ˆ$1 \le u_i, v_i \le n$ï¼‰ï¼Œè¾¹æƒä¸º $w_i$ï¼ˆ$1 \le w_i \le 100$ï¼‰ï¼ä½ éœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼šæ±‚å‡ºä» $1$ åˆ° $n$ æœ€çŸ­è·¯å¾„çš„æƒå€¼å’Œï¼Œä»¥åŠè¾“å‡ºä»»æ„ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼
>
> **è¾“å…¥æ ¼å¼**ï¼šç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° $n$ å’Œ $m$ï¼æ¥ä¸‹æ¥ $m$ è¡Œæ¯è¡Œè¾“å…¥ä¸‰ä¸ªæ•´æ•° $u_i,v_i,w_i$ï¼
>
> **è¾“å‡ºæ ¼å¼**ï¼šç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•° $\mathit{sum}$ï¼Œè¡¨ç¤ºç¬¬ä¸€é—®çš„ç­”æ¡ˆï¼ç¬¬äºŒè¡Œé¦–å…ˆè¾“å‡ºä¸€ä¸ªåœ¨ $[1,n^2]$ åŒºé—´å†…çš„æ•´æ•° $\mathit{len}$ï¼Œè¡¨ç¤ºæœ€çŸ­è·¯å¾„ç»è¿‡çš„ç‚¹æ•°ï¼ç„¶åè¾“å‡º $\mathit{len}$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€çŸ­è·¯å¾„ä¾æ¬¡ç»è¿‡çš„ç»“ç‚¹ç¼–å·ï¼ˆéœ€è¦åŒ…å«æœ€å¼€å§‹çš„ $1$ å’Œæœ€æœ«å°¾çš„ $n$ï¼‰ï¼

ç¼–å†™æ›´å¤æ‚çš„ checker æ—¶ï¼Œå»ºè®®ä½¿ç”¨ã€ŒInputã€å’Œã€ŒOutputã€ç»“æ„ä½“åŠå…¶å„è‡ªçš„ã€Œreadã€å’Œã€Œevaluateã€æ–¹æ³•æ¥æ„å»ºé€»è¾‘ï¼è¿™ç§æ–¹æ³•å¯ä»¥ä½¿å®ç°æ›´å…·å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼

```cpp filename="chk.cpp" copy showLineNumbers
#include <map>
#include <optional>
#include <string>
#include <utility>
#include <vector>

#include "cplib.hpp"

using namespace cplib;

// Define an Edge struct for reading graph edges
struct Edge {
  int u, v, w;

  // Edge::read takes a Reader and the graph size 'n' as context
  static Edge read(var::Reader& in) {
    // Using in() operator for reading multiple variables conveniently
    auto [u, v, w] = in(var::i32("u"), var::i32("v"), var::i32("w"));
    return {u, v, w};
  }
};

// Define the Input struct to hold graph data
struct Input {
  int n, m;
  std::map<std::pair<int, int>, int> graph; // Adjacency map for quick edge lookup

  static Input read(var::Reader& in) {
    auto [n, m] = in(var::i32("n"), var::i32("m"));
    // Read 'm' edges, passing 'n' as context to Edge::read via var::ExtVar
    auto edges = in.read(var::ExtVar<Edge>("edges") * m);

    std::map<std::pair<int, int>, int> graph;
    for (auto [u, v, w] : edges) {
      graph[{u, v}] = w;
      graph[{v, u}] = w; // Undirected graph
    }

    return {n, m, std::move(graph)};
  }
};

// Define the Output struct to hold the shortest path sum and the path itself
struct Output {
  int sum, len;
  std::vector<int> plan;

  // Output::read takes Reader and the Input struct as context
  static Output read(var::Reader& in, const Input& input) {
    // Read sum and length, with appropriate ranges
    auto sum = in.read(var::i32("sum", 0, std::nullopt));
    auto len = in.read(var::i32("len", 1, input.n * input.n)); // Max path length for N nodes

    // Read the path plan, ensuring nodes are within [1, input.n]
    auto plan = in.read(var::i32("plan", 1, input.n) * len);

    // Perform validity checks on the path
    if (plan.empty()) in.fail("Path cannot be empty");
    if (plan.front() != 1) in.fail("Path should begin with 1");
    if (plan.back() != input.n) in.fail("Path should end with n");

    int result_sum = 0;
    for (int i = 1; i < (int)plan.size(); ++i) {
      if (!input.graph.count({plan[i - 1], plan[i]}))
        in.fail(format("Edge {} <-> {} does not exist", plan[i - 1], plan[i]));
      result_sum += input.graph.at({plan[i - 1], plan[i]});
    }

    if (result_sum != sum)
      in.fail(format("Calculated path sum ({}) from plan does not match reported sum ({})",
                     result_sum, sum));

    return {sum, len, plan};
  }

  // Output::evaluate compares participant's output with jury's output
  static evaluate::Result evaluate(evaluate::Evaluator& ev, const Output& pans, const Output& jans,
                                   const Input&) {
    auto res = evaluate::Result::ac();

    // If participant's sum is strictly less than jury's sum,
    // it implies the jury's answer is not optimal. This is an internal error.
    if (pans.sum < jans.sum) {
      ev.fail(
          format("Participant's path sum ({}) is less than jury's path sum ({})! This indicates a "
                 "judge error.",
                 pans.sum, jans.sum));
    }

    // The problem asks for the shortest path sum.
    // If participant's sum is greater than jury's, it's WA.
    res &= ev.eq("sum", pans.sum, jans.sum);

    // If sums are equal, the path itself needs to be valid (already checked in read)
    // and correctly connects 1 to n (also checked in read).
    // No further comparison of 'plan' is strictly needed if 'sum' is correct,
    // as any valid path yielding the shortest sum is acceptable.
    // However, for completeness or stricter checks, one might compare 'len' or 'plan'
    // if multiple shortest paths exist and specific ones are preferred.
    // For this problem, we only care about the sum.

    return res;
  }
};

// Register the checker
CPLIB_REGISTER_CHECKER(Input, Output);
```

è¿™ä¸ªä¾‹å­æ¼”ç¤ºäº†å¦‚ä½•ä¸ºè‡ªå®šä¹‰ç±»å‹ä½¿ç”¨å˜é‡è¯»å–æ¨¡æ¿ä»¥åŠå¦‚ä½•ç»„ç»‡è¯„ä¼°é€»è¾‘ï¼

**ç»“æ„åŒ–æ•°æ®ç±»å‹å’Œ `read` æ–¹æ³•ï¼š**

- **`Edge` ç»“æ„ä½“**ï¼šå®šä¹‰å•ä¸ªè¾¹çš„ç»“æ„ï¼å…¶ `static read` æ–¹æ³•è¯»å– `u`ã€`v` å’Œ `w`ï¼
- **`Input` ç»“æ„ä½“**ï¼šå°è£…äº† `n`ã€`m` å’Œå›¾çš„é‚»æ¥æ˜ å°„ï¼å…¶ `static read` æ–¹æ³•è¯»å– `n` å’Œ `m`ï¼Œç„¶åä½¿ç”¨ `var::ExtVar<Edge>("edges") * m` è¯»å– `m` æ¡è¾¹ï¼`var::ExtVar<T>` ç”¨äºä¸ºè‡ªå®šä¹‰ç±»å‹ `T` åˆ›å»ºå˜é‡è¯»å–æ¨¡æ¿ï¼å½“ `T::read` éœ€è¦é¢å¤–å‚æ•°æ—¶ï¼Œè¿™äº›å‚æ•°ä¼šä¼ é€’ç»™ `var::ExtVar<T>` çš„æ„é€ å‡½æ•°ï¼å¯¹äºæœ¬ä¾‹ä¸­çš„ `Edge` ç±»å‹ï¼Œå…¶ `Edge::read` æ–¹æ³•åªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œæ„é€ å‡½æ•°é™¤äº† `name` ä¹‹å¤–ä¸éœ€è¦ä¼ é€’ä»»ä½•å‚æ•°ï¼`in` çš„ `operator()`ï¼ˆä¾‹å¦‚ `in(var::i32("n"), var::i32("m"))`ï¼‰æä¾›äº†ä¸€ç§ç®€æ´çš„æ–¹å¼ï¼Œå°† **æ²¡æœ‰ç›¸äº’ä¾èµ–å…³ç³»** çš„å¤šä¸ªå˜é‡è¯»å–åˆ° `std::tuple` ä¸­ï¼
- **`Output` ç»“æ„ä½“**ï¼šä¿å­˜æŠ¥å‘Šçš„æ€»å’Œã€è·¯å¾„é•¿åº¦å’Œè·¯å¾„æœ¬èº«ï¼å…¶ `static read` æ–¹æ³•æ‰§è¡Œå…³é”®çš„ã€Œæœ‰æ•ˆæ€§ã€æ£€æŸ¥ï¼š
  - ç¡®ä¿è·¯å¾„èŠ‚ç‚¹åœ¨ `[1, input.n]` èŒƒå›´å†…ï¼
  - éªŒè¯è·¯å¾„ä»¥ `1` å¼€å§‹å¹¶ä»¥ `n` ç»“æŸï¼
  - æ£€æŸ¥è·¯å¾„ä¸­çš„æ‰€æœ‰è¾¹æ˜¯å¦å­˜åœ¨äºå›¾ä¸­ï¼
  - ç¡®è®¤æŠ¥å‘Šçš„ `sum` ä¸ä» `plan` è®¡ç®—å‡ºçš„æ€»å’ŒåŒ¹é…ï¼
  - å¦‚æœä»»ä½•æœ‰æ•ˆæ€§æ£€æŸ¥å¤±è´¥ï¼Œå°†è°ƒç”¨ `in.fail(message)`ï¼Œè¿™å°†ç«‹å³æŠ¥å‘Šã€ŒWrong Answerã€ï¼ˆå¯¹äºé€‰æ‰‹è¾“å‡ºï¼‰æˆ–ã€ŒInternal Errorã€ï¼ˆå¯¹äºè¯„æµ‹æ–¹è¾“å‡ºï¼‰ï¼Œå¹¶é™„å¸¦è¯¦ç»†çš„å †æ ˆè·Ÿè¸ªï¼

å¯¹äºè¯»å–è‡ªå®šä¹‰ç±»å‹çš„é›†åˆï¼Œä¸”æ¯ä¸ªå…ƒç´ çš„è§£æéƒ½ä¾èµ–äºä¸Šä¸‹æ–‡ä¿¡æ¯ï¼ˆå¦‚å…¶ç´¢å¼•æˆ–æ¥è‡ªå¦ä¸€ä¸ªé›†åˆçš„å¯¹åº”å…ƒç´ ï¼‰çš„åœºæ™¯ï¼ŒCPLib æä¾›äº† `cplib::var::ExtVec<T>`ï¼å®ƒä¼šéå†ä¸€ä¸ªç»™å®šçš„èŒƒå›´ï¼ˆä¾‹å¦‚ `std::views::iota` æˆ–å¦ä¸€ä¸ª `std::vector`ï¼‰ï¼Œå¹¶å¯¹èŒƒå›´ä¸­çš„æ¯ä¸ªå…ƒç´ è°ƒç”¨ `T::read`ï¼ŒåŒæ—¶å°†è¯¥èŒƒå›´å…ƒç´ ä½œä¸ºé¢å¤–å‚æ•°ä¼ é€’ï¼è¿™é¿å…äº†æ‰‹åŠ¨å¾ªç¯ï¼Œä½¿ä»£ç æ›´å…·å£°æ˜æ€§ï¼ä¾‹å¦‚ï¼Œè¦è¯»å– `T` ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå…¶ä¸­æ¯ä¸ª `TestCaseInput::read` éƒ½éœ€è¦å…¶ç´¢å¼•ï¼š

```cpp copy
auto test_cases = in.read(cplib::var::ExtVec<TestCaseInput>(
    "test_cases",
    std::views::iota(0, T),
    cplib::var::Separator(std::nullopt) // æµ‹è¯•ç”¨ä¾‹ä¹‹é—´æ²¡æœ‰åˆ†éš”ç¬¦
));
```

**ä½¿ç”¨ `evaluate::Evaluator` è¿›è¡Œè¯„ä¼°ï¼š**

`Output::evaluate` æ–¹æ³•æ˜¯æ ¸å¿ƒã€Œç­‰ä»·æ€§ã€æ£€æŸ¥å‘ç”Ÿçš„åœ°æ–¹ï¼

- å®ƒæ¥æ”¶ä¸€ä¸ª `evaluate::Evaluator& ev`ï¼Œè¿™æ˜¯æŠ¥å‘Šç»“æœçš„ä¸»è¦å·¥å…·ï¼
- å¤„ç†äº†ä¸€ä¸ªç‰¹æ®Šæƒ…å†µï¼šå¦‚æœ `pans.sum < jans.sum`ï¼Œè¿™æ„å‘³ç€é€‰æ‰‹æ‰¾åˆ°äº†æ¯”è¯„æµ‹æ–¹ç­”æ¡ˆ *æ›´å¥½* çš„ç­”æ¡ˆï¼è¿™è¡¨æ˜è¯„æµ‹æ–¹è§£å†³æ–¹æ¡ˆæˆ–æµ‹è¯•æ•°æ®å­˜åœ¨é—®é¢˜ï¼æ­¤å¤„ä½¿ç”¨ `ev.fail()` æŠ¥å‘Šã€ŒInternal Errorã€ï¼ˆå†…éƒ¨é”™è¯¯ï¼‰å¹¶é™„å¸¦ç‰¹å®šæ¶ˆæ¯ï¼Œæç¤ºå®¡æŸ¥è¯„æµ‹æ–¹ç­”æ¡ˆï¼è¿™æ˜¯ä¸€ç§å¤„ç†æ­¤ç±»æƒ…å†µçš„å¥å£®æ–¹æ³•ï¼Œå°†å…¶ä¸å¸¸è§„çš„ã€ŒWrong Answerã€åŒºåˆ†å¼€æ¥ï¼
- `ev.eq("sum", pans.sum, jans.sum)` æ£€æŸ¥é€‰æ‰‹çš„æ€»å’Œï¼ˆ`pans.sum`ï¼‰æ˜¯å¦ç­‰äºè¯„æµ‹æ–¹çš„æ€»å’Œï¼ˆ`jans.sum`ï¼‰ï¼å¦‚æœ `pans.sum > jans.sum`ï¼Œå®ƒä¼šè‡ªåŠ¨æ ‡è®°ä¸ºã€ŒWrong Answerã€å¹¶é™„å¸¦æè¿°æ€§æ¶ˆæ¯ï¼

## å»ºè®®

æ€»ä¹‹ï¼Œåœ¨ç¼–å†™æ›´å¤æ‚çš„ checker æ—¶ï¼Œæˆ‘ä»¬å»ºè®®ä»¥ä¸‹å‡ ç‚¹ï¼š

- **ç»„ç»‡ä»£ç ç»“æ„**ï¼šä½¿ç”¨è‡ªå®šä¹‰çš„ `Input` å’Œ `Output` ç»“æ„ä½“åŠå…¶ `static read` å’Œ `static evaluate` æ–¹æ³•ï¼è¿™ç§æ¨¡å—åŒ–è®¾è®¡æé«˜äº†å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ï¼
- **åˆ©ç”¨ `var::Var`**ï¼šä¸ºè‡ªå®šä¹‰ç±»å‹ä½¿ç”¨ `cplib::var::ExtVar`ï¼Œä¸º vector ä½¿ç”¨ `operator*`ï¼`in` çš„ `operator()` å¯ä»¥ç®€åŒ–è¯»å–å¤šä¸ªç‹¬ç«‹å˜é‡ï¼
- **åœ¨ `read` æ–¹æ³•ä¸­æ‰§è¡Œã€Œæœ‰æ•ˆæ€§ã€æ£€æŸ¥**ï¼šåœ¨ `Output` ç»“æ„ä½“åŠå…¶åµŒå¥—ç±»å‹çš„ `static read` æ–¹æ³•ä¸­å®ç°å¯¹è¾“å‡ºæ ¼å¼ã€èŒƒå›´å’ŒåŸºæœ¬ä¸€è‡´æ€§ï¼ˆä¾‹å¦‚ï¼Œè·¯å¾„èµ·ç‚¹/ç»ˆç‚¹æ˜¯å¦æ­£ç¡®ï¼Œè¾¹æ˜¯å¦å­˜åœ¨ï¼‰çš„æ£€æŸ¥ï¼ä½¿ç”¨ `in.fail("message")` æŠ¥å‘Šè¿™äº›é”™è¯¯ï¼
- **åœ¨ `evaluate` æ–¹æ³•ä¸­æ‰§è¡Œã€Œç­‰ä»·æ€§ã€æ£€æŸ¥**ï¼šåœ¨ `Output` ç»“æ„ä½“çš„ `static evaluate` æ–¹æ³•ä¸­å®ç°é€‰æ‰‹è¾“å‡ºå’Œè¯„æµ‹æ–¹è¾“å‡ºä¹‹é—´çš„æ ¸å¿ƒé€»è¾‘æ¯”è¾ƒï¼ä½¿ç”¨ `evaluate::Evaluator` æ–¹æ³•ï¼ˆå¦‚ `ev.eq`ã€`ev.approx`ã€`ev.fail`ï¼‰è¿›è¡Œå¥å£®ä¸”æè¿°æ€§çš„ç»“æœæŠ¥å‘Šï¼

<Callout>
å¦‚æœä½ æƒ³è¦è‡ªå·±åŠ¨æ‰‹æ“ä½œï¼Œå¯ä»¥ï¼š

å°è¯•ç¼–å†™ä»¥ä¸‹é¢˜ç›®çš„ checkerï¼

**é¢˜ç›®æè¿°**ï¼šå¯¹äºä¸€ä¸ª $n$ï¼ˆ$1 \le n \le 10^5$ï¼‰ä¸ªèŠ‚ç‚¹ $m$ï¼ˆ$1 \le m \le 10^5$ï¼‰æ¡æ— å‘è¾¹çš„å›¾ï¼Œè¯·è¾“å‡ºå…¶è¾¹åŒè¿é€šåˆ†é‡çš„ä¸ªæ•°ï¼Œå¹¶ä¸”è¾“å‡ºæ¯ä¸ªè¾¹åŒè¿é€šåˆ†é‡ï¼

**è¾“å…¥æ ¼å¼**ï¼šç¬¬ä¸€è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° $n$ å’Œ $m$ï¼æ¥ä¸‹æ¥ $m$ è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° $u,v$ï¼Œè¡¨ç¤ºä¸€æ¡æ— å‘è¾¹ï¼

**è¾“å‡ºæ ¼å¼**ï¼šç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $x$ è¡¨ç¤ºè¾¹åŒè¿é€šåˆ†é‡çš„ä¸ªæ•°ï¼æ¥ä¸‹æ¥çš„ $x$ è¡Œï¼Œæ¯è¡Œç¬¬ä¸€ä¸ªæ•° $a$ è¡¨ç¤ºè¯¥åˆ†é‡ç»“ç‚¹ä¸ªæ•°ï¼Œç„¶å $a$ ä¸ªæ•°ï¼Œæè¿°ä¸€ä¸ªè¾¹åŒè¿é€šåˆ†é‡ï¼ä½ å¯ä»¥ä»¥ä»»æ„é¡ºåºè¾“å‡ºè¾¹åŒè¿é€šåˆ†é‡ä¸è¾¹åŒè¿é€šåˆ†é‡å†…çš„ç»“ç‚¹ï¼

å‚è€ƒå®ç°è§ [GitHub ä»“åº“](https://github.com/rindag-devs/cplib/tree/main/tests/checker/3-set-of-sets)ï¼
</Callout>
